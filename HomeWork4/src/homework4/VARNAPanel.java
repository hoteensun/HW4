/*    VARNA is a Java library for quick automated drawings RNA secondary structure     Copyright (C) 2007  Yann Ponty    This program is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program.  If not, see <http://www.gnu.org/licenses/>. */package homework4;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.MouseMotionListener;import java.awt.geom.*;import java.awt.image.BufferedImage;import java.io.FileOutputStream;import java.io.OutputStream;import java.text.ParseException;import java.util.Vector;import javax.swing.*;//import com.sun.image.codec.jpeg.JPEGCodec;//import com.sun.image.codec.jpeg.JPEGImageEncoder;/** * The RNA 2D Panel is a lightweight component that allows for  * an automatic basic drawing of an RNA secondary structures. * The drawing algorithms do not ensure a non-overlapping drawing * of helices, thus it is possible to "spin the helices" through a * click-and-drag approach. A typical usage of the class from within  * the constructor of a <code>JFrame</code> would be the following:<br/> * <code> * &nbsp;&nbsp;RNAPanel _rna = new RNAPanel("CCCCAUAUGGGGACC","((((....))))...");<br /> * &nbsp;&nbsp;this.getContentPane().add(_rna); * </code> * @version 1.0 * @author Yann Ponty * */public class VARNAPanel extends JPanel {		private static final long serialVersionUID = 1L;	static final int DRAW_MODE_UNKNOWN = -1; 	/**	 * Selects the "Feynman diagram" drawing algorithm that places	 * the bases on a circle and draws the base-pairings as chords 	 * of the circle graph.	 */	public static final int DRAW_MODE_CIRCLE = 1; 	/**	 * Selects the "tree drawing" algorithm. Draws	 * each loop on a circle whose radius depends on the number of bases involved	 * in the loop. As some helices can be overlapping in the result, basic 	 * interaction is provided so that the user can "disentangle" the drawing 	 * by spinning the helices around the axis defined by their multiloop 	 * (bulge or internal loop) origin. This is roughly the initial placement 	 * strategy of RNAViz.	 * @see <a href="http://rnaviz.sourceforge.net/">RNAViz</a>	 */	public static final int DRAW_MODE_RADIATE = 2; 			private int BORDER = 15; 	private EmbeddedRNA _r = new EmbeddedRNA();	private Color BACKBONE_COLOR = Color.black;	private Color BOND_COLOR = Color.blue;	private Color BASE_OUTLINE_COLOR = Color.DARK_GRAY;	private Color BASE_INNER_COLOR = new Color(230,230,230);	private Color BASE_NUMBERS_COLOR = Color.DARK_GRAY;	private Color BASE_NAME_COLOR = Color.black;	private Color TITLE_COLOR = Color.black;	private int TITLE_HEIGHT = 30;	private int _numPeriod = 5;	private boolean _autoFit = true;	private boolean _autoCenter = true;	private Font _titleFont;	private String _title="";	private String _titleFontFamily="Arial";	private String _titleFontStyle="PLAIN";	private int _titleFontSize=18;	private String _baseFontFamily="Arial";	private String _baseFontStyle="BOLD";	private int _baseFontSize=18;	private Font _baseNameFont;	private int _drawMode = DRAW_MODE_UNKNOWN;			private BasicStroke dashed;	private RealPoint[] _realCoords=new RealPoint[0];	private int _selectedBase = -1;	private double _scaleFactor = 1.0;	private RealPoint _offsetPanel = new RealPoint();	private RealPoint _offsetRNA = new RealPoint();			/**	 * Creates an RNA 2D panel with initially displays the empty structure.	 */	public VARNAPanel()	{		this("","",DRAW_MODE_RADIATE);	}	/**	 * Creates an RNA 2D panel, and creates and displays an RNA coupled	 * with its secondary structure formatted as a well-balanced parenthesis	 * with dots word (DBN format).	 * @param seq The raw nucleotide sequence	 * @param str The secondary structure in DBN format	 */	public VARNAPanel(String seq, String str)	{		this(seq,str,DRAW_MODE_RADIATE);	}	/**	 * Creates an RNA 2D panel, and creates and displays an RNA coupled	 * with its secondary structure formatted as a well-balanced parenthesis	 * with dots word (DBN format). Allows the user to choose the drawing	 * algorithm to be used.	 * @param seq The raw nucleotide sequence	 * @param str The secondary structure in DBN format	 * @param drawMode The drawing mode	 * @see #DRAW_MODE_CIRCLE	 * @see #DRAW_MODE_RADIATE	 */	public VARNAPanel(String seq, String str,int drawMode)	{		this(seq,str,drawMode,"");	}		/**	 * Creates an RNA 2D panel, and creates and displays an RNA coupled	 * with its secondary structure formatted as a well-balanced parenthesis	 * with dots word (DBN format). Allows the user to choose the drawing	 * algorithm to be used. Additionally, sets the panel's title. 	 * @param seq The raw nucleotide sequence	 * @param str The secondary structure in DBN format	 * @param drawMode The drawing mode	 * @param title The panel title	 * @see #DRAW_MODE_CIRCLE	 * @see #DRAW_MODE_RADIATE	 */	public VARNAPanel(String seq, String str,int drawMode,String title)	{		super();		_title = title;		_drawMode = drawMode;		setRNA(seq,str);		init();	}		JPopupMenu popup= new JPopupMenu();		private void init()	{		float[] ds = new float[2];		ds[0] = 5.0f;		ds[1] = 5.0f;		dashed = new BasicStroke(2.0f,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND,3.0f,ds,0.0f);		this.setBackground(Color.white);		GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();		Font[] avlFonts = ge.getAllFonts();				_baseNameFont = Font.decode(""+_baseFontFamily+"-"+_baseFontStyle+"-"+_baseFontSize);		_titleFont = Font.decode(""+_titleFontFamily+"-"+_titleFontStyle+"-"+_titleFontSize);		this.setFont(_baseNameFont);			    buildPopupMenu();			    this.addMouseListener(new MouseListener(){			public void mouseClicked(MouseEvent arg0) {}			public void mouseEntered(MouseEvent arg0) {}			public void mouseExited(MouseEvent arg0) {}			public void mousePressed(MouseEvent arg0) 			{onMousePressed(arg0);}			public void mouseReleased(MouseEvent arg0) {}});		this.addMouseMotionListener(new MouseMotionListener(){			public void mouseDragged(MouseEvent me) {				if(_selectedBase!=-1)				{					if (_drawMode == VARNAPanel.DRAW_MODE_CIRCLE)					{						moveSingleAtom(_selectedBase, me.getX(),me.getY());					}					else					{						moveHelixAtom(_selectedBase, me.getX(),me.getY());					}				}			}			public void mouseMoved(MouseEvent arg0) {			}});	}			public void onMousePressed(MouseEvent arg0)    {		if (arg0.getButton()==1)		{			// TODO Auto-generated method stub			if (_realCoords != null)			{  				double dist=Double.MAX_VALUE;				for(int i=0;i<_realCoords.length;i++)				{					double d2 =Math.sqrt(Math.pow((_realCoords[i].x-arg0.getX()),2)							  + Math.pow((_realCoords[i].y-arg0.getY()),2)); 					if((dist>d2)&&(_r._str.getBP(i)!=-1))					{ 						_selectedBase = i;						dist = d2;					}				}				//System.out.println("[1]"+_selectedBase);			}		}		else		{ 			_selectedBase = -1;			popup.show(this,arg0.getX(),arg0.getY());		}    }		void reset()	{		setRNA(_r._str,_drawMode);	}				/**	 * Sets the RNA secondary structure to be drawn in this panel, using the default layout algorithm. 	 * In addition to the raw nucleotides sequence, the secondary structure is given 	 * in the so-called "Dot-bracket notation" (DBN) format.	 * This format is a well-parenthesized word over the alphabet '(',')','.'.<br/>	 * Ex: <code>((((((((....))))..(((((...))).))))))</code><br />	 * Returns <code>true</code> if the sequence/structure couple could be parsed into a	 * valid secondary structure, and <code>false</code> otherwise.	 * @param seq The raw nucleotides sequence	 * @param str The secondary structure	 * @return <code>true</code> if the sequence/structure couple could be parsed into a	 * valid secondary structure, <code>false</code> otherwise	 */	public boolean setRNA(String seq, String str)	{		return setRNA(seq,str,_drawMode);	}	/**	 * Sets the RNA secondary structure to be drawn in this panel, using a given layout algorithm. 	 * @param r The new secondary structure	 * @param drawMode The drawing algorithm	 */	public void setRNA(RNASecStr r, int drawMode)	{		_drawMode=drawMode;		setRNA(r);	}			/**	 * Sets the RNA secondary structure to be drawn in this panel, using the current drawing algorithm. 	 * @param r The new secondary structure	 */	public void setRNA(RNASecStr r)	{		if (r!=null)		{			Embedding coords;			switch(_drawMode)			{			case DRAW_MODE_RADIATE:					coords = EmbeddedRNA.drawRNASecStr(r);					break;			case DRAW_MODE_CIRCLE:					coords = EmbeddedRNA.drawRNASecStrCircle(r);					break;			default : 					coords = new Embedding();		  	  	break;			}			_r = new EmbeddedRNA(r,coords);		}	}		/**	 * Sets the RNA secondary structure to be drawn in this panel, using a given layout algorithm. 	 * In addition to the raw nucleotides sequence, the secondary structure is given 	 * in the so-called "Dot-bracket notation" (DBN) format.	 * This format is a well-parenthesized word over the alphabet '(',')','.'.<br/>	 * Ex: <code>((((((((....))))..(((((...))).))))))</code><br />	 * Returns <code>true</code> if the sequence/structure couple could be parsed into a	 * valid secondary structure, and <code>false</code> otherwise.	 * @param seq The raw nucleotides sequence	 * @param str The secondary structure	 * @param drawMode The drawing algorithm	 * @return <code>true</code> if the sequence/structure couple could be parsed into a	 * valid secondary structure, <code>false</code> otherwise	 */	public boolean setRNA(String seq, String str, int drawMode)	{		_drawMode=drawMode;		if (seq.length()!=str.length())		{ 			System.err.println("Sequence length "+seq.length()+" differs from that of secondary structure "+str.length()+". \nAdapting sequence length ...");			if (seq.length()<str.length())			{				while (seq.length()<str.length())				{					seq += " ";				}			}			else			{				seq = seq.substring(0,str.length());			}		}		RNASecStr r=null;		try{		r = new RNASecStr(seq,str);		}catch(ParseException e)		{			System.err.println(e.getMessage());			System.err.println("Invalid secondary structure at char "+e.getErrorOffset()+".");			return false;		}		Embedding coords;		switch(_drawMode)		{		  case DRAW_MODE_RADIATE:				coords = EmbeddedRNA.drawRNASecStr(r);			  break;		  case DRAW_MODE_CIRCLE:				coords = EmbeddedRNA.drawRNASecStrCircle(r);			  break;		  default : 				coords = new Embedding();		  	  break;		}		_r = new EmbeddedRNA(r,coords);    	return true;	}	/**	 * Sets the new style of the title font.	 * @param newStyle A string that describes the new font style ("PLAIN","BOLD", "BOLDITALIC", or "ITALIC")	 */	public void setTitleFontStyle(String newStyle)	{		_titleFontStyle = newStyle;		_titleFont = Font.decode(""+_titleFontFamily+"-"+_titleFontStyle+"-"+_titleFontSize);	}	/**	 * Sets the new size of the title font.	 * @param newSize The new size of the title font 	 */	public void setTitleFontSize(int newSize)	{		_titleFontSize = newSize;		_titleFont = Font.decode(""+_titleFontFamily+"-"+_titleFontStyle+"-"+_titleFontSize);	}	/**	 * Sets the new font family to be used for the title. Available fonts are system-specific, yet 	 * it seems that "Arial", "Dialog", and "MonoSpaced" are almost always available. 	 * @param newFamily New font family used for the title	 */	public void setTitleFontFamily(String newFamily)	{		_titleFontFamily = newFamily;		_titleFont = Font.decode(""+_titleFontFamily+"-"+_titleFontStyle+"-"+_titleFontSize);	}	/**	 * Sets the color to be used for the title.	 * @param newColor A color used to draw the title	 */	public void setTitleFontColor(Color newColor)	{		TITLE_COLOR = newColor;	}	/**	 * Sets the new style of the base name.	 * @param newStyle A string that describes the new font style ("PLAIN","BOLD", "BOLDITALIC", or "ITALIC")	 */	public void setBaseFontStyle(String newStyle)	{		_baseFontStyle = newStyle;		_baseNameFont = Font.decode(""+_titleFontFamily+"-"+_titleFontStyle+"-"+_titleFontSize);	}	/**	 * Sets the new size of the base name.	 * @param newSize The new size of the base font 	 */	public void setBaseFontSize(int newSize)	{		_baseFontSize = newSize;		_baseNameFont = Font.decode(""+_titleFontFamily+"-"+_titleFontStyle+"-"+_titleFontSize);	}	/**	 * Sets the new font family to be used for the base names. Available fonts are system-specific, yet 	 * it seems that "Arial", "Dialog", and "MonoSpaced" are almost always available. 	 * @param newFamily New font family used for the base names	 */	public void setBaseFontFamily(String newFamily)	{		_baseFontFamily = newFamily;		_baseNameFont = Font.decode(""+_titleFontFamily+"-"+_titleFontStyle+"-"+_titleFontSize);	}	/**	 * Sets the color to be used for the base names.	 * @param newColor A color used to draw the base names	 */	public void setBaseFontColor(Color newColor)	{		BASE_NAME_COLOR = newColor;	}	/**	 * Sets the panel's title, giving a short description of the RNA secondary structure.	 * @param title The new title	 */	public void setTitle(String title)	{		_title = title;	}	/**	 * Sets the background color of the Panel.	 * @param newColor A color used for the backgound	 */	public void setBackground(Color newColor)	{		super.setBackground(newColor);	}		/**	 * Sets the distance between consecutive base numbers. 	 * Bases whose internal number is a multiple of the period will display their base number 	 * "outside" of the secondary structure.	 * The first base is always numbered.	 * @param n New numbering period	 */	public void setNumPeriod(int n)	{		_numPeriod = n;		repaint();	}		void setAutoFit(boolean fit)	{		_autoFit = fit;		repaint();	}		void setRNA(EmbeddedRNA r)	{		_r = r;	}		    private Dimension getStringDimension(Graphics2D g, String s)    {    	FontMetrics fm = g.getFontMetrics();    	Rectangle2D r = fm.getStringBounds(s, g);    	return (new Dimension((int)r.getWidth(),(int)fm.getAscent()-fm.getDescent()));    }	private void drawStringCentered(Graphics2D g2, String res,double x, double y)    {    	Dimension d = getStringDimension(g2, res);    	x -= (double)d.width/2.0;    	y += (double)d.height/2.0;    	//g2.drawRect(x, y-d.height, d.width, d.height);    	g2.drawString(res, (int)x, (int)y);    }    private void drawBase(Graphics2D g2, int i, char res,RealPoint p,RealPoint center, double newRadius)    {    	//res = Character.toTitleCase(res);    	g2.setColor(BASE_INNER_COLOR);    	g2.fillOval((int)(p.x-newRadius), (int)(p.y-newRadius), (int)(2.0*newRadius), (int)(2.0*newRadius));    	g2.setColor(BASE_OUTLINE_COLOR);    	g2.drawOval((int)(p.x-newRadius), (int)(p.y-newRadius), (int)(2*newRadius), (int)(2*newRadius));    	String label = ""+res;    	g2.setColor(BASE_NAME_COLOR);    	drawStringCentered(g2,label,p.x,p.y);    	if ((i==0)||((i+1)%_numPeriod==0))    	{    		double d1 = p.distance(center);    		double distLabel = (d1+2.5*newRadius)/d1;    		double vx = (p.x-center.x);    		double vy = (p.y-center.y);    		g2.setColor(BASE_NUMBERS_COLOR);    		drawStringCentered(g2,""+(i+1), center.x+vx*distLabel, center.y+vy*distLabel);    	}    }	    private void updateBaseFontSize(int size)    {		_baseFontSize = size;		_baseNameFont = Font.decode(_baseFontFamily+"-"+_baseFontStyle+"-"+_baseFontSize);		setFont(_baseNameFont);    }    	private void renderRNA(Graphics2D g2, RealRectangle bbox)	{		RealRectangle rnabbox = _r.getBBox();		if (_autoFit)		{			_scaleFactor = Math.min((double)bbox.width/(double)rnabbox.width,(double)bbox.height/(double)rnabbox.height);		}		double offX = bbox.x;		double offY = bbox.y;		if(_autoCenter)		{		  offX =  (bbox.x +  (bbox.width-Math.round(rnabbox.width*_scaleFactor))/2.0);		  offY =  (bbox.y +  (bbox.height-Math.round(rnabbox.height*_scaleFactor))/2.0);		}		//g2.drawRect((int)offX,(int)offY,(int)rnabbox.width,(int)rnabbox.height);		double newWidth = (_scaleFactor*rnabbox.width);		double newHeight = (_scaleFactor*rnabbox.height);		double newRadius = Math.max(1.0,(_scaleFactor*EmbeddedRNA.BASE_RADIUS));    	int newFontSize = Math.max(1, (int)((1.7*EmbeddedRNA.BASE_RADIUS)*_scaleFactor));		_offsetPanel = new RealPoint(offX,offY);		_offsetRNA = new RealPoint(rnabbox.x,rnabbox.y);    	    	// Re-scaling once and for all    	RealPoint[] newCoords = new RealPoint[_r.getSize()];    	RealPoint[] newCenters = new RealPoint[_r.getSize()];    	for(int i=0;i<_r.getSize();i++)    	{   			RealPoint p = _r.getCoord(i);   			newCoords[i] = new RealPoint(offX+(_scaleFactor*(p.x-rnabbox.x)),offY+(_scaleFactor*(p.y-rnabbox.y)));   			RealPoint c = _r.getCenter(i);   			newCenters[i] = new RealPoint(offX+(_scaleFactor*(c.x-rnabbox.x)),offY+(_scaleFactor*(c.y-rnabbox.y)));    	}    	    	// Keep track of coordinates for mouse interactions    	_realCoords = newCoords;    	    	updateBaseFontSize(newFontSize);    	BasicStroke plain = new BasicStroke((int)(2.0*_scaleFactor),BasicStroke.JOIN_ROUND,BasicStroke.CAP_ROUND);        //g2.setFont(_baseNameFont);    	// Drawing backbone    	g2.setColor(BACKBONE_COLOR);		g2.setStroke(plain);    	    	for(int i=1;i<_r.getSize();i++)		{			g2.drawLine((int)newCoords[i-1].x, (int)newCoords[i-1].y, (int)newCoords[i].x, (int)newCoords[i].y);		}    	// Drawing base-pairs    	g2.setColor(BOND_COLOR);		g2.setStroke(plain);    	    	for(int i=0;i<_r.getSize();i++)		{    		int j = _r.getBP(i);    		if(j>i)    		{g2.drawLine((int)newCoords[i].x, (int)newCoords[i].y, (int)newCoords[j].x, (int)newCoords[j].y);}		}    	    	// Drawing bases		g2.setStroke(plain);		g2.setFont(_baseNameFont);    	for(int i=0;i<_r.getSize();i++)		{			char c = _r.getRes(i);			drawBase(g2,i,c,newCoords[i],newCenters[i],newRadius);		}    	// Drawing bbox    	//g2.setColor(Color.GRAY);		//g2.setStroke(dashed);		//g2.drawRect(offX, offY, newWidth, newHeight);	}    	public void paintComponent(Graphics g2)	{		super.paintComponent(g2);		Graphics2D g = (Graphics2D) g2;		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON );		g.setColor(getBackground());		g.fillRect(0, 0, this.getWidth(), this.getHeight());				g.setColor(TITLE_COLOR);		int width = this.getWidth();		int height = this.getHeight();		if (!_title.equals(""))		{			g2.setFont(_titleFont);			drawStringCentered(g,_title,width/2,height-TITLE_HEIGHT/2.0);			height -= TITLE_HEIGHT;		}		int innerWidth=width-2*BORDER;		int innerHeight=height-2*BORDER;		int leftOffset=BORDER+((width-2*BORDER)-innerWidth)/2;		int topOffset=BORDER+((height-2*BORDER)-innerHeight)/2;				// Display outer rectangle		g.setColor(Color.GRAY);		g.setStroke(dashed);		//g.drawRect(leftOffset, topOffset, innerWidth, innerHeight);				// Draw RNA		renderRNA(g,new RealRectangle(leftOffset,topOffset,innerWidth,innerHeight));	}		private RealPoint panelToLogicPoint(RealPoint p)	{		return new RealPoint(((p.x-_offsetPanel.x)/_scaleFactor)+_offsetRNA.x,				((p.y-_offsetPanel.y)/_scaleFactor)+_offsetRNA.y);	}	private void moveSingleAtom(int index, int x, int y)	{		if((index>=0)&&(index<_r.getSize()))		{		  RealPoint pr = _realCoords[index];		  RealPoint pold = _r.getCoord(index);		  double dx = ((x-pr.x)/_scaleFactor);		  double dy = ((y-pr.y)/_scaleFactor);		  		  _r.setCoord(index, pold.x+dx,pold.y+dy);		  this.repaint();		}	}		private void moveHelixAtom(int index, int x, int y)	{		if((index>=0)&&(index<_r.getSize()))		{		  RNASecStr r = _r.getRNASecStr();		  int indexTo = r.getBP(index); 		  if(indexTo!=-1)		  {			  Range h = _r.getHelix(index);			  Range ml = _r.getMultiLoop(h.begin);			  			  int i = ml.begin;			  if((ml.begin==0)||(ml.end==_r.getSize()-1))			  {return ;}			  int prevIndex = h.begin;			  int nextIndex = h.end;			  while(i<=ml.end)			  {				  int j = _r.getBP(i);				  if((j!=-1)&&(i<h.begin))				  {					  prevIndex = i;				  }				  if((j!=-1)&&(i>h.end)&&(nextIndex==h.end))				  {					  nextIndex = i;				  }				  if((j>i)&&(j<ml.end))				  { 					  i=_r.getBP(i);				  }				  else				  {i++;}			  }			  RealPoint p = new RealPoint(x,y);			  RealPoint oldPos = _r.getCoord(index);			  RealPoint limitLoopLeft = _r.getCoord(ml.end);			  RealPoint limitLoopRight = _r.getCoord(ml.begin);			  RealPoint limitLeft = _r.getCoord(prevIndex);			  RealPoint limitRight = _r.getCoord(nextIndex);			  RealPoint helixStart = _r.getCoord(h.begin);			  RealPoint helixStop = _r.getCoord(h.end);			  RealPoint center = _r._em._centers[h.begin];              RealPoint newPos = panelToLogicPoint(p);			  double base = (computeAngle(center,limitLoopRight)+computeAngle(center,limitLoopLeft))/2.0;			  double pLimR = computeAngle(center,limitLeft)-base;			  double pHelR = computeAngle(center,helixStart)-base;			  double pNew = computeAngle(center,newPos)-base;			  double pOld = computeAngle(center,oldPos)-base;			  double pHelL = computeAngle(center,helixStop)-base;			  double pLimL = computeAngle(center,limitRight)-base;			  //System.out.printf("Base:%.2f =>  %.2f < %.2f < [%.2f,%.2f] < %.2f < %.2f\n",base, pLimR,pHelR,pNew,pOld,pHelL,pLimL);			  if(pLimR<0.0) pLimR += 2.0*Math.PI;			  if((pHelR<0.0)||(pHelR<pLimR)) pHelR += 2.0*Math.PI;			  if((pNew<0.0)|| (pNew<pHelR)) pNew += 2.0*Math.PI;			  if((pOld<0.0)|| (pOld<pHelR)) pOld += 2.0*Math.PI;			  if((pHelL<0.0) || (pHelL<pOld)) pHelL += 2.0*Math.PI;			  if((pLimL<0.0) || (pLimL<pHelL)) pLimL += 2.0*Math.PI;			  //System.out.printf("Corrected:%.2f =>  %.2f < %.2f < [%.2f,%.2f] < %.2f < %.2f\n",base, pLimR,pHelR,pNew,pOld,pHelL,pLimL);			  			  double minDelta = (normalizeAngle(pHelR)-normalizeAngle(pLimR));			  double maxDelta = normalizeAngle(pLimL)-normalizeAngle(pHelL);			  //double maxDelta = 300;			  			  double delta = normalizeAngle(pNew)-normalizeAngle(pOld);			  			  			  delta = Math.max(-minDelta+0.25,delta);			  delta = Math.min(maxDelta-0.25,delta);			  rotateHelix(center, h.begin,h.end, delta);			  			  // Re-assigns unpaired atoms			  boolean over = false;			  helixStart = _r.getCoord(h.begin);			  helixStop = _r.getCoord(h.end);			  pHelR = computeAngle(center,helixStop)-base;			  pHelL = computeAngle(center,helixStart)-base;			  i = h.begin-1;			  Vector<Integer> nextBases = new Vector<Integer>();			  while(!over)			  {				  if(i<0)				  {over = true;}				  else				  {					  if (_r.getBP(i)==-1)					  {nextBases.add(new Integer(i));}					  else					  {over = true;}				  }				  i--;			  }			  Vector<Integer> prevBases = new Vector<Integer>();			  over = false;			  i=h.end+1;			  while(!over)			  {				  if(i>=_r.getSize())				  {over = true;}				  else				  {					  if (_r.getBP(i)==-1)					  {prevBases.add(new Integer(i));}					  else					  {over = true;}				  }				  i++;			  }			  double radius = center.distance(helixStart);			  double anglePrev = normalizeAngle(pLimL-pHelR);			  			  for(i=0;i<prevBases.size();i++)			  {				  int k = prevBases.get(i).intValue();				  double newAngle = base+pHelR+((i+1)*anglePrev)/(prevBases.size()+1);				  double newX = center.x+radius*Math.cos(newAngle);				  double newY = center.y+radius*Math.sin(newAngle);				  _r.setCoord(k, newX, newY);			  }			  double angleNext = normalizeAngle(pHelL-pLimR);			  //System.out.println(nextBases);			  for(i=0;i<nextBases.size();i++)			  {				  int k = nextBases.get(i).intValue();				  double newAngle = base+pHelL-((i+1)*angleNext)/(nextBases.size()+1);				  double newX = center.x+radius*Math.cos(newAngle);				  double newY = center.y+radius*Math.sin(newAngle);				  _r.setCoord(k, newX, newY);			  }			  		  }		}	}		private double normalizeAngle(double angle)	{		return normalizeAngle(angle,0.0);	}	private double normalizeAngle(double angle, double base)	{		while(angle<base)		{ angle += 2.0*Math.PI;	}		while(angle>=(2.0*Math.PI)-base)		{ angle -= 2.0*Math.PI;	}		return angle;	}			private double computeAngle(RealPoint center, RealPoint p)	{		double dist = center.distance(p);        double angle = Math.asin((p.y-center.y)/dist);		if (p.x-center.x<0)		{ angle = Math.PI-angle; }		return angle;	}			private RealPoint rotatePoint(RealPoint center,RealPoint p, double angle)	{		double dist = p.distance(center);		double oldAngle = Math.asin((p.y-center.y)/dist);		if (p.x-center.x<0)		{ oldAngle = Math.PI-oldAngle; }		double newX = (center.x+dist*Math.cos(oldAngle+angle));		double newY = (center.y+dist*Math.sin(oldAngle+angle));		return new RealPoint(newX,newY);	}		private void rotateHelix(RealPoint center, int i, int j, double angle)	{				for(int k=i;k<=j;k++)		{			RealPoint oldp = _r.getCoord(k);			RealPoint newp = rotatePoint(center,oldp,angle);			_r.setCoord(k,newp );			if ((k!=i)&&(k!=j))			{				RealPoint oldc = _r._em._centers[k];				RealPoint newc = rotatePoint(center,oldc,angle);				_r._em._centers[k]=newc;			}		}		repaint();	}		/**	 * Returns the RNA secondary structure diplayed by this panel as a well-parenthesized	 * word, accordingly to the DBN format	 * @return This panel's secondary structure	 */	public String getStructDBN()	{		String result = "";		for(int i=0;i<_r.getSize();i++)		{			int j = _r.getBP(i);			if (j==-1)			{				result += ".";			}			else if (i>j)			{				result += ")";			}			else			{				result += "(";			}		}				return result;	}		/**	 * Returns the raw nucleotides sequence for the displayed RNA	 * @return The RNA sequence	 */	public String getSeq()	{		String result = "";		for(int i=0;i<_r.getSize();i++)		{			result += _r.getRes(i);		}				return result;	}    /**     * Returns the color used to draw backbone bounds.     * @return The color used to draw backbone bounds     */	public Color getBackboneColor() {		return BACKBONE_COLOR;	}	/**	 * Sets the color to be used for drawing backbone interactions.	 * @param backbone_color The new color for the backbone bounds	 */	public void setBackboneColor(Color backbone_color) {		BACKBONE_COLOR = backbone_color;	}	/**	 * Returns the color to be used for displaying the inner part of bases.	 * @return The color for the inner part of bases	 */	public Color getBaseInnerColor() {		return BASE_INNER_COLOR;	}	/**	 * Sets the color to be used for displaying the inner part of bases.	 * @param base_inner_color The new color for the inner part of bases	 */	public void setBaseInnerColor(Color base_inner_color) {		BASE_INNER_COLOR = base_inner_color;	}	/**	 * Returns the color to be used for drawing nucleotide names.	 * @return The color for nucleotide names	 */	public Color getBaseNameColor() {		return BASE_NAME_COLOR;	}	/**	 * Sets the color to be used for drawing nucleotide names.	 * @param base_name_color The new color for nucleotide names	 */	public void setBaseNameColor(Color base_name_color) {		BASE_NAME_COLOR = base_name_color;	}	/**	 * Returns the color to be used for displaying nucleotides numbers.	 * @return The color of nucleotide numbers	 */	public Color getBaseNumbersColor() {		return BASE_NUMBERS_COLOR;	}	/**	 * Sets the color to be used for displaying nucleotides numbers.	 * @param base_numbers_color The new color of nucleotide numbers	 */	public void setBaseNumbersColor(Color base_numbers_color) {		BASE_NUMBERS_COLOR = base_numbers_color;	}	/**	 * Returns the color used to display the external part of nucleotides (external circle). 	 * @return The color used to display the external part of nucleotides	 */	public Color getBaseOutlineColor() {		return BASE_OUTLINE_COLOR;	}	/**	 * Sets the new color used to display the external part of nucleotides (external circle).	 * @param base_outline_color The new color of the external nucleotides circle	 */	public void setBaseOutlineColor(Color base_outline_color) {		BASE_OUTLINE_COLOR = base_outline_color;	}	/**	 * Returns the color used to display hydrogen bonds (base pairings)	 * @return The color of hydrogen bonds	 */	public Color getBondColor() {		return BOND_COLOR;	}	/**	 * Returns the title of this panel 	 * @return The title	 */	public String getTitle() {		return _title;	}	/**	 * Sets the new color to be used for hydrogen bonds (base pairings)	 * @param bond_color The new color for hydrogen bonds	 */	public void setBondColor(Color bond_color) {		BOND_COLOR = bond_color;	}	/**	 * Sets the size of the border, i.e. the empty space between the end of the drawing area	 * and the actual border.	 * @param b The new border size	 */	public void setBorderSize(int b) {		BORDER = b;	}	/**	 * Returns the size of the border, i.e. the empty space between the end of the drawing area	 * @return The border size	 */	public int getBorderSize() {		return BORDER;	}		/**	 * Recomputes the layout of the secondary structure, using a previously set	 * drawing strategy.	 * @see #DRAW_MODE_CIRCLE	 * @see #DRAW_MODE_RADIATE	 */	public void redoLayout()	{		setRNA(new String(_r._str._seq),_r._str.getStructDBN());	}	/**	 * Recomputes the layout of the secondary structure. The result will	 * depend on the chosen drawing strategy.	 * @param drawMode The drawing strategy	 * @see #DRAW_MODE_CIRCLE	 * @see #DRAW_MODE_RADIATE	 */	public void redoLayout(int drawMode)	{		_drawMode = drawMode;		setRNA(new String(_r._str._seq),_r._str.getStructDBN());	}    private void buildPopupMenu()    {	    // Reset menuitem		JMenuItem redisplay = new JMenuItem("Reset");		redisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				reset();			}});	    // Drawing algorithm menu		JMenu submenuAlgo = new JMenu("Redraw");	    JMenuItem algoCircle = new JMenuItem("Circular");	    algoCircle.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				setRNA(_r._str, VARNAPanel.DRAW_MODE_CIRCLE);				}});	    JMenuItem algoRadiate = new JMenuItem("Radiate");	    algoRadiate.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				setRNA(_r._str,VARNAPanel.DRAW_MODE_RADIATE);				}});	    submenuAlgo.add(algoCircle);	    submenuAlgo.add(algoRadiate);	    	    // Export menu	    JMenu submenuExport = new JMenu("Export");	    JMenu submenuExportStructure = new JMenu("Structure");	    JMenu submenuExportImage = new JMenu("Image");	    JMenuItem exportDBN = new JMenuItem("DBN (dotbracket) Format");	    exportDBN.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIExportDBN();			}});	    JMenuItem exportBPSEQ = new JMenuItem("BPSEQ Format");	    exportDBN.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIExportBPSEQ();			}});	    JMenuItem exportCT = new JMenuItem("CT Format");	    exportDBN.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIExportCT();			}});	    JMenuItem exportEPS = new JMenuItem("EPS Picture");	    exportEPS.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIExportEPS();			}});	    JMenuItem exportXFIG = new JMenuItem("XFIG File");	    exportXFIG.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIExportXFIG();			}});	    JMenuItem exportJPEG = new JMenuItem("JPEG Picture");	    exportJPEG.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIExportJPEG();			}});	    	    submenuExport.add(submenuExportImage);	    submenuExport.add(submenuExportStructure);	    submenuExportStructure.add(exportDBN);	    submenuExportStructure.add(exportCT);	    submenuExportStructure.add(exportBPSEQ);	    submenuExportImage.add(exportEPS);	    submenuExportImage.add(exportXFIG);	    submenuExportImage.add(exportJPEG);	    // Input menu	    JMenu submenuImport = new JMenu("Open");	    JMenuItem manualInput = new JMenuItem("User input");	    manualInput.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIManualInput();			}});	    JMenuItem diskInput = new JMenuItem("File");	    diskInput.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIFileInput();			}});	    	    submenuImport.add(diskInput);	    submenuImport.add(manualInput);	    	    // Input menu	    JMenu submenuDisplay = new JMenu("Display");	    JMenu colorsDisplay = new JMenu("Colors");	    JMenuItem backgroundDisplay = new JMenuItem("Background");	    backgroundDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIBackgroundDisplay();			}});	    JMenuItem baseInnerDisplay = new JMenuItem("Bases inner");	    baseInnerDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIBaseInnerDisplay();			}});	    JMenuItem baseOuterDisplay = new JMenuItem("Bases outer");	    baseOuterDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIBaseOuterDisplay();			}});	    JMenuItem backboneDisplay = new JMenuItem("Backbone");	    backboneDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIBackboneColorDisplay();			}});	    JMenuItem bondsDisplay = new JMenuItem("Bonds");	    bondsDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIBondsDisplay();			}});	    JMenu fontsDisplay = new JMenu("Fonts");	    JMenuItem titleDisplay = new JMenuItem("Title");	    titleDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UITitleDisplay();			}});	    	    JMenuItem baseDisplay = new JMenuItem("Bases");	    baseDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIBaseDisplay();			}});	    	    JMenuItem titleContentDisplay = new JMenuItem("Title");	    titleContentDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UITitleContentDisplay();			}});	    JMenuItem borderDisplay = new JMenuItem("Border Size");	    borderDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UIBorderDisplay();			}});	    JMenuItem numPeriodDisplay = new JMenuItem("Num Period");	    numPeriodDisplay.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent arg0) {				UINumPeriod();			}});        colorsDisplay.add(backgroundDisplay);        colorsDisplay.add(backboneDisplay);        colorsDisplay.add(baseInnerDisplay);        colorsDisplay.add(baseOuterDisplay);        colorsDisplay.add(bondsDisplay);        fontsDisplay.add(titleDisplay);        fontsDisplay.add(baseDisplay);	    submenuDisplay.add(colorsDisplay);	    submenuDisplay.add(fontsDisplay);	    submenuDisplay.add(titleContentDisplay);	    submenuDisplay.add(borderDisplay);	    submenuDisplay.add(numPeriodDisplay);	    	    popup.add(submenuImport);	    popup.add(submenuExport);	    popup.addSeparator();	    popup.add(submenuAlgo);	    popup.addSeparator();	    popup.add(submenuDisplay);	    //popup.add(redisplay);	    this.add(popup);    }    private void UIBaseDisplay()    {    	String family = selectFont("Base font", "Please select a new font for bases:",this.getFont());    	setBaseFontFamily(family);    }    private void UITitleDisplay()    {    	String family = selectFont("Title font", "Please select a new font for the title:", this.getFont());    	setTitleFontFamily(family);    }        private String selectFont(String title, String message,Font defaultFont)    {	  GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();      String [] polices = ge.getAvailableFontFamilyNames();      JLabel msg = new JLabel(message);      JComboBox l = new JComboBox(polices);      JPanel p = new JPanel();      p.setLayout(new GridLayout(1,2));      p.add(l);      p.add(msg);	  JOptionPane.showConfirmDialog(this,l,title,JOptionPane.OK_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE);	  return (String)l.getSelectedItem();    }    	private void UIBaseOuterDisplay()    {        Color c = JColorChooser.showDialog(this, "Choose new base outline color", this.getBackground());           if (c != null)	    { this.setBaseOutlineColor(c); }          }	private void UIBaseInnerDisplay()    {        Color c = JColorChooser.showDialog(this, "Choose new base filling color", this.getBackground());           if (c != null)	    { this.setBaseInnerColor(c); }          }	private void UIBackboneColorDisplay()    {        Color c = JColorChooser.showDialog(this, "Choose new backbone color", this.getBackground());           if (c != null)	    { this.setBackboneColor(c); }          }	private void UIBondsDisplay()    {        Color c = JColorChooser.showDialog(this, "Choose new bonds color", this.getBackground());           if (c != null)	    { this.setBondColor(c); }          }	private void UIBackgroundDisplay()    {        Color c = JColorChooser.showDialog(this, "Choose new background color", this.getBackground());           if (c != null)	    { this.setBackground(c); }          }	  private void UIExportDBN()	    {	        JFileChooser fc = new JFileChooser();		    if (fc.showSaveDialog(VARNAPanel.this)==JFileChooser.APPROVE_OPTION)		    {		    	_r._str.exportDBN(fc.getSelectedFile().getAbsolutePath(), this._title);		    }      	    }	  	   private void UIExportBPSEQ()	    {	        JFileChooser fc = new JFileChooser();		    if (fc.showSaveDialog(VARNAPanel.this)==JFileChooser.APPROVE_OPTION)		    {		    	_r._str.exportBPSEQ(fc.getSelectedFile().getAbsolutePath(), this._title);		    }      	    }	   private void UIExportCT()	    {	        JFileChooser fc = new JFileChooser();		    if (fc.showSaveDialog(VARNAPanel.this)==JFileChooser.APPROVE_OPTION)		    {		    	_r._str.exportCT(fc.getSelectedFile().getAbsolutePath(), this._title);		    }      	    }		private void UIExportEPS()    {        JFileChooser fc = new JFileChooser();	    if (fc.showSaveDialog(VARNAPanel.this)==JFileChooser.APPROVE_OPTION)	    {	    	_r.saveEmbeddedRNAEPS(fc.getSelectedFile().getAbsolutePath(), _title,_numPeriod);	    }          }	private void UIExportXFIG()    {        JFileChooser fc = new JFileChooser();	    if (fc.showSaveDialog(VARNAPanel.this)==JFileChooser.APPROVE_OPTION)	    {	    	_r.saveEmbeddedRNAXFIG(fc.getSelectedFile().getAbsolutePath(), _title,_numPeriod);	    }          }			private void UIExportJPEG()    {        JFileChooser fc = new JFileChooser();	    if (fc.showSaveDialog(VARNAPanel.this)==JFileChooser.APPROVE_OPTION)	    {	    	saveToJPEG(fc.getSelectedFile().getAbsolutePath());	    }          }		private void UIFileInput()	{        JFileChooser fc = new JFileChooser();	    if (fc.showOpenDialog(VARNAPanel.this)==JFileChooser.APPROVE_OPTION)	    {	    	RNASecStr s = RNASecStr.loadSecStr(fc.getSelectedFile().getAbsolutePath());	    	setRNA(s);	    }      			}    private void UIManualInput()    {        JPanel p = new JPanel();        JPanel pup = new JPanel();        JPanel pdown = new JPanel();        p.setLayout(new GridLayout(2,1));        pup.setLayout(new FlowLayout(FlowLayout.LEFT));        pdown.setLayout(new FlowLayout(FlowLayout.LEFT));		Font _textFieldsFont = Font.decode("MonoSpaced-PLAIN-12");        JLabel lseq = new JLabel("Sequence: ");        JTextField tseq = new JTextField(getSeq());        JLabel lstr = new JLabel("Structure: ");        JTextField tstr = new JTextField(this.getStructDBN());        tstr.setPreferredSize(new Dimension(400,tstr.getPreferredSize().height));        tseq.setPreferredSize(new Dimension(400,tseq.getPreferredSize().height));        tstr.setFont(_textFieldsFont);        tseq.setFont(_textFieldsFont);        pup.add(lseq);        pup.add(tseq);        pdown.add(lstr);        pdown.add(tstr);        p.add(pup);        p.add(pdown);	    if (JOptionPane.showConfirmDialog(this,p,"Input sequence/structure",JOptionPane.OK_CANCEL_OPTION)==JOptionPane.OK_OPTION)	    {	    	setRNA(tseq.getText(),tstr.getText());	    }          }    private void UINumPeriod()    {        JSlider numPeriodSlider = new JSlider(JSlider.HORIZONTAL,1 , (_r.getSize())/2, _numPeriod);        //Turn on labels at major tick marks.        numPeriodSlider.setMajorTickSpacing(10);        numPeriodSlider.setMinorTickSpacing(5);        numPeriodSlider.setPaintTicks(true);        numPeriodSlider.setPaintLabels(true);	    if (JOptionPane.showConfirmDialog(this,numPeriodSlider,"Set new numbering period",JOptionPane.OK_CANCEL_OPTION)==JOptionPane.OK_OPTION)	    {	    	this.setNumPeriod(numPeriodSlider.getValue());	    }          }    private void UIBorderDisplay()    {        JSlider borderSlider = new JSlider(JSlider.HORIZONTAL,10 , 10+(getWidth()-10)/2, BORDER);        //Turn on labels at major tick marks.        borderSlider.setMajorTickSpacing(50);        borderSlider.setMinorTickSpacing(10);        borderSlider.setPaintTicks(true);        borderSlider.setPaintLabels(true);	    if (JOptionPane.showConfirmDialog(this,borderSlider,"Set new border size",JOptionPane.OK_CANCEL_OPTION)==JOptionPane.OK_OPTION)	    {	    	this.setBorderSize(borderSlider.getValue());	    }          }        private void UITitleContentDisplay() {			String res = JOptionPane.showInputDialog(this, "Input title", this.getTitle());			if (res != null)		    {		    	this.setTitle(res);		    }      						}    public void saveToJPEG(String filename) {//        Dimension size = getSize();////        BufferedImage myImage = ////          new BufferedImage(size.width, size.height, BufferedImage.TYPE_INT_RGB);////        Graphics2D g2 = myImage.createGraphics();////        this.paint(g2);////        try {////          OutputStream out = new FileOutputStream(filename);////          JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);////          encoder.encode(myImage);////          out.close();////        } catch (Exception e) {////          System.out.println(e); ////        }      }          }